@ Ryan Bentz
@ 372 Project 2 - Part 1
@ This program initializes a New Haven LCD and displays my name.
@ It uses the I2C protocol in a polling configuration to
@ interact with the display.

.data
.align 2
@ define stack sizes
@--------------------------------------------------------------------
LED_STATUS: 	.word 0x00
STACK1:			.rept 1024
				.word 0x00
				.endr
STACK2:			.rept 1024
				.word 0x00
				.endr
				
@ define word messages to send
@--------------------------------------------------------------------
MESSAGE:		.ascii "@RYAN BENTZ" @ ---- "@" symbol for the control/data byte
.align 4
INIT_0: .byte 0x00, 0x38
INIT_1: .byte 0x00, 0x39
@INIT_2: .byte 0x00, 0x14, 0x78, 0x5E, 0x6D, 0x0C, 0x01, 0x06
INIT_2: .byte 0x00, 0x14, 0x78, 0x5E
INIT_3: .byte 0x00, 0x6D, 0x0C, 0x01, 0x06
				
.text
.global _start
.global INT_DIRECTOR
_start:

@ Define the Register Addressed, Offsets, and write values to control the LEDs
.equ	DELAY_1S, 0x0022DCD5
.equ	DELAY_1MS,0x37C7B

@ Initialize the stack frames
@--------------------------------------------------------------------
LDR R13, =STACK1					@ initialize stack one for supervisor mode
ADD R13, R13, #0x1000				@ point stack pointer to top of stack
CPS #0x12							@ change to IRQ mode
LDR R13, =STACK2					@ initialize stack for IRQ mode
ADD R13, R13, #0x1000				@ point stack pointer to top of stack
CPS #0x13							@ change back to supervisor mode


@ Initialize the peripheral clocks
@--------------------------------------------------------------------
@ initialize the clock to I2C1
LDR R0, =0x44E00048					@ CMPER.I2C1_CLKCTRL
LDR R1, [R0]
MOV	R2, #0x02
ORR R1, R1, R2
STR R1, [R0]

@ Delay 1s and wait for peripheral clocks
@--------------------------------------------------------------------
LDR R0, =DELAY_1S
BL DELAY

@ Initialize the I2C
@--------------------------------------------------------------------
@ initialize the GPIO pins for the I2C functions
@ set the SCL pin
LDR R0, =0x44E1095C					@ CONTROL.conf_spi0_cs0
LDR R1, [R0]
AND R1, R1, #0xFFFFFFF8				@ mask bits [2:0]
ORR R1, R1, #0x02					@ enable mode 2
STR R1, [R0]

@ set the SDA pin
LDR R0, =0x44E10958					@ CONTROL.conf_spi0_d1
LDR R1, [R0]
AND R1, R1, #0xFFFFFFF8				@ mask bits [2:0]
ORR R1, R1, #0x02					@ enable mode 2
STR R1, [R0]

@ set I2C ICLK prescaler
LDR R0, =0x4802A0B0					@ I2C_PSC: Clock prescaler register
LDR R1, [R0]
MOV	R2, #0x4						@ 48 MHz clock / 4 = 12 MHz clock
ORR R1, R1, R2
STR R1, [R0]

@ set SCLL value
LDR R0, =0x4802A0B4					@ I2C_SCLL: Low time register
LDR R1, [R0]
MOV	R2, #0x35
ORR R1, R1, R2
STR R1, [R0]

@ set SCLH value
LDR R0, =0x4802A0B8					@ I2C_SCLH: High time register
LDR R1, [R0]
MOV	R2, #0x37
ORR R1, R1, R2
STR R1, [R0]

@ take the I2C module out of reset mode
LDR R0, =0x4802A0A4					@ I2C_CON: Control register
LDR R1, [R0]
MOV	R2, #0x8000
ORR R1, R1, R2
STR R1, [R0]

@ configure I2C mode register without setting STT and STP
LDR R0, =0x4802A0A4					@ I2C_CON: Control register
LDR R1, [R0]
LDR R2, =0xFFFF0000
AND R1, R1, R2
ORR R1, R1, #0x8600		@ 7-bit address: 0x8600, 10-bit address: 0x8700
STR R1, [R0]

@ enable interrupt masks

@ configure the slave address
LDR R0, =0x4802A0AC					@ I2C_SA: Slave address register
LDR R1, [R0]
AND R1, R1, #0x0000
ORR R1, R1, #0x3C
STR R1, [R0]

@ clear the TX FIFO
LDR R0, =0x4802A094
LDR R1, [R0]
ORR R1, R1, #0x40
STR R1, [R0]

@ Delay 1s and wait for module
@--------------------------------------------------------------------
LDR R0, =DELAY_1S
BL DELAY

@ Initialize the display
@--------------------------------------------------------------------
INIT_DISPLAY:

LDR R0, =INIT_0
MOV R1, #0x02
BL I2C_TRANSMIT_PROC

LDR R0, =DELAY_1MS
BL DELAY

LDR R0, =INIT_1
MOV R1, #0x02
BL I2C_TRANSMIT_PROC

LDR R0, =DELAY_1MS
BL DELAY

LDR R0, =INIT_2
MOV R1, #0x04
BL I2C_TRANSMIT_PROC

LDR R0, =DELAY_1MS
BL DELAY

LDR R0, =INIT_3
MOV R1, #0x05
BL I2C_TRANSMIT_PROC

LDR R0, =DELAY_1MS
BL DELAY


@ transmit command to display "RYAN BENTZ"
LDR R0, =MESSAGE
MOV R1, #0xB
BL I2C_TRANSMIT_PROC

@ wait 1 ms
LDR R0, =DELAY_1MS
BL DELAY



@ MAIN LOOP
@--------------------------------------------------------------------
MAIN_LOOP:
	NOP				@ do nothing and wait for interrupt
	B MAIN_LOOP				
	B END


@--------------------------------------------------------------------
I2C_TRANSMIT_PROC:
@ R0 = Address of bytes to send 
@ R1 = Number of bytes to write
@ R2 = Data Register Address
@ R3 = Value of data to write

STMFD R13!, {R0-R5, R14}		@ save the register states and link register location

@ check that the bus is ready
TX_WAIT:
	LDR R4, =0x4802A024			@ I2C_IRQSTATUS_RAW
	LDR R5, [R4]
	MOV R6, #0x1000				@ Check Bit 12: Bus Busy Status
	AND R5, R5, R6
	CMP R5, #0x1000				@ If BB = 1, bus is occupied
	BEQ TX_WAIT

@ initialize the counter register
LDR R4, =0x4802A098
STR R1, [R4]

@ write the transmit data to the FIFO
DATA_QUEUE:
	LDR 	R2, =0x4802A09C			@ I2C_DATA Register
	LDRB 	R3, [R0], #1			@ get the value of the data to send and post increment index
	STRB 	R3, [R2]				@ write the value to the FIFO
	SUBS 	R1, #1					@ decrement the number of bytes to send
	BNE	DATA_QUEUE

@ set module to master mode on every transfer
LDR R4, =0x4802A0A4					@ I2C_CON: Control register
LDR R5, [R4]
ORR R5, R5, #0x400					@ Master mode bit 10
STR R5, [R4]

@ configure the start/stop bits
LDR R4, =0x4802A0A4			@ I2C_CON: Control Register
LDR R5, [R4]
MOV R6, #0x03				@ Set the STT and STP bits to initiate transfer
ORR R5, R5, R6
@ begin transmitting data by setting the start/stop bits
STR R5, [R4]

LDMFD R13!, {R0-R5, PC}			@ return execution from the procedure


@---------------------------------------------------------------------------- 
@ Delay Loop Subroutine
@ Handles the delay loop timing
DELAY:
STMFD R13!, {R4, R14}	@ save the register states and link register location
D_LOOP:
	NOP
	SUBS R0, #1
	BNE D_LOOP
LDMFD R13!, {R4, PC}
	
END:
.END